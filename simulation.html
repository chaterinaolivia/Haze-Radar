<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>HazeRadar ‚Äî External Wind-Driven Haze Simulation (Dynamic Visuals)</title>

<!-- Bootstrap CSS for styling and layout -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- Leaflet CSS for the map -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>
/* Custom Dark Theme Styles using Inter font */
:root { 
    --bg:#0b1222; 
    --card:#172033; 
    --muted:#9fb2c8;
    --primary-color: #06b6d4; /* cyan-500 */
    --accent-color: #f97316; /* orange-600 */
    --text-light: #e9f7ff; /* Pure white/light color for text */
}

html, body {
    height: 100%; 
    margin: 0; 
    background: var(--bg); 
    color: var(--text-light); /* Apply light text color globally */
    font-family: Inter, Roboto, Arial, sans-serif;
}

.app {
    display: flex; 
    height: 100vh;
}

/* Sidebar Styling */
#sidebar {
    width: 350px; 
    padding: 18px; 
    border-right: 1px solid rgba(255,255,255,0.06); 
    background: #111827;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    box-shadow: 2px 0 10px rgba(0,0,0,0.5);
    overflow-y: auto; /* Ensure inputs are visible */
}

#map {
    flex: 1;
}

h2 {
    font-size: 1.5rem;
    color: var(--primary-color);
    font-weight: 700;
}

/* Panel Card Styling */
.panel {
    background: var(--card); 
    padding: 16px; 
    border-radius: 12px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.08);
}

/* Button Primary Overrides (for simulation) */
.btn-primary {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    font-weight: 600;
    transition: background-color 0.2s;
    border-radius: 8px;
}

.btn-primary:hover {
    background-color: #ea580c; /* darker orange */
    border-color: #ea580c;
}

/* Dropdown/Form Select Styling */
.form-select, .form-control {
    background-color: #2c3e50;
    color: var(--text-light);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
}

.form-select:focus, .form-control:focus {
    background-color: #2c3e50;
    color: var(--text-light);
    border-color: var(--primary-color);
    box-shadow: 0 0 0 0.25rem rgba(6, 182, 212, 0.25);
}

/* Slider Panel Styling */
#sliderPanel {
    display: none;
    flex-direction: column;
    gap: 0.75rem;
}

/* Slider Track/Thumb Overrides (Minimal styling for dark theme visibility) */
#hourSlider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    outline: none;
}

#hourSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    margin-top: -4px;
}

#hourSlider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

/* Status/Toast Box */
.toastBox {
    font-size: 1rem; 
    margin-top: 10px; 
    color: var(--primary-color);
    font-weight: 500;
    min-height: 20px;
}

/* City Marker Styles */
/* REMOVED .leaflet-interactive.city-marker:hover {} to prevent shaking/scaling */
.leaflet-interactive.city-marker {
    cursor: default; /* Keep cursor standard */
    transition: all 0.2s ease-in-out;
}

/* Fixed CSS for the descriptive text */
.sidebar-description {
    color: var(--text-light) !important; /* Forces the text color to white/light */
    font-size: 0.95rem;
}

/* === Replay Link Styles (White to Orange) === */
#replayBtn {
    color: var(--text-light); /* White text */
    text-align: center;
    cursor: pointer;
    font-size: 1rem; 
    font-weight: 600;
    padding: 8px 0; /* Add vertical padding for a larger click target */
    display: block; /* Takes full width */
    text-decoration: none;
    transition: color 0.2s;
}

#replayBtn:hover {
    color: var(--accent-color); /* Orange on hover */
    text-decoration: underline;
}
/* =========================================== */


/* === NEW STYLES FOR SCROLLABLE WIND DATA === */
#windForecastDisplay {
    max-height: 150px; /* Fixed height */
    overflow-y: auto; /* Enable vertical scrolling */
    padding: 5px; 
    border: 1px solid #374151; 
    border-radius: 4px; 
}

/* --- FIX FOR INSTRUCTION TEXT COLOR --- */
.text-light-override {
    color: var(--text-light) !important;
}
/* =========================================== */

/* Responsive considerations for smaller screens */
@media (max-width: 768px) {
    .app {
        flex-direction: column;
    }
    #sidebar {
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.06);
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    #map {
        height: 50vh; 
    }
}
</style>
</head>
<body>
<div class="app">

<div id="sidebar">
    <h2>Wind-Driven Haze Simulation</h2>

    <a href="index.html" class="btn btn-outline-light btn-sm mb-3">
        ‚Üê Back to HazeRadar Map
    </a>
    
    <!-- FIXED DESCRIPTION TEXT -->
    <div class="sidebar-description">
        This model simulates 5 days (120 hours) of haze spread. The plume radius indicates spread over time (age), while color indicates PM2.5 concentration.
    </div>

    <div class="panel">
    <strong>1. Select Starting City</strong>
    <select id="cityDropdown" class="form-select mt-2">
        <option value="">‚Äî Select a City ‚Äî</option>
        <!-- Cities loaded here by JS -->
        <option value="custom">‚Äî Set Custom Location on Map ‚Äî</option>
    </select>
    <div id="customInstructions" class="text-xs text-center text-light-override" style="display:none;">
        Click anywhere on the map to set the starting point.
    </div>
</div>
    
    <div class="panel">
    <strong>2. 5-Day (120 Hour) Wind Forecast (Open-Meteo Fetch)</strong>
    <div id="windForecastDisplay" class="mt-2 text-sm text-light">
        <p class="text-center text-light-override">Select a city or custom location, then press 'Run Haze Simulation'.</p>
    </div>
</div>

<button id="simulateLocal" class="btn btn-primary btn-lg w-100">Run Haze Simulation</button>

    <div id="sliderPanel" class="panel">
    <strong>Timeline Control</strong>
    <input id="hourSlider" type="range" min="1" max="120" value="1">
    <div id="hourLabel" class="mt-2 text-center">Hour: 1</div>
    
        <div class="form-check form-switch mt-3 d-flex justify-content-center">
        <input class="form-check-input" type="checkbox" id="viewModeToggle" checked>
        <label class="form-check-label ms-2" for="viewModeToggle" id="toggleLabel">Cumulative View</label>
    </div>
        
    <!-- CHANGED TO TEXT LINK -->
    <span id="replayBtn" class="w-100 mt-2">Replay Animation</span>
</div>

    <div id="statusBox" class="toastBox">Ready.</div>
</div>

<div id="map"></div>
</div>

<!-- Leaflet JS Library -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // ------------------------------------------
    // --- MAP AND CONSTANTS ---
    // ------------------------------------------
    
    // Endpoint to fetch the list of city coordinates 
    const API_ROOT = "https://haze-radargnnmodelstimulation-production.up.railway.app";
    const map = L.map("map").setView([-1.5, 113], 5);

    // Use a dark tile layer for better visualization contrast
    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
        maxZoom: 18,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    }).addTo(map);

    let cityCoordinates = {};
    let cityMarkers = [];
    let hazeLayers = [];
    let predictions = [];
    let autoplayInterval = null;
    
    // Custom location state
    let customStartLat = null;
    let customStartLon = null;
    let customStartMarker = null; 
    let isMapClickEnabled = false; // Control flag for map clicks

    // Store single 120-hour forecast
    let hourlyWindForecast = []; 

    // --- Simulation Constants ---
    const INITIAL_PM25 = 150; 
    const HAZE_DECAY = 0.98; 
    const DEGREE_PER_KMH = 0.00005; // Conversion factor for movement
    const MAX_HOURS = 120; // 5 days
    // Degrees to Meters conversion factor at the equator (approx 111,320m per degree)
    const DEG_PER_METER = 1 / 111320; 

    // --- Visual Constants (Radius now indicates spread over time) ---
    const MIN_RADIUS_M = 200; 
    const MAX_RADIUS_M = 1000; 
    
    // --- Plume/Satellite Configuration ---
    const NUM_SATELLITES = 8; 
    
    // Ratio of satellite scatter distance relative to the *visual radius* of the plume.
    const SATELLITE_RADIUS_RATIO = 2.0; 

    // --- Utility Functions ---

    function toast(msg){ document.getElementById("statusBox").innerText = msg; }

    // Helper function for color interpolation (RGB)
    function interpolateColor(color1, color2, factor) {
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
        }
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = Math.round(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        const rgb1 = hexToRgb(color1);
        const rgb2 = hexToRgb(color2);

        const r = rgb1[0] + (rgb2[0] - rgb1[0]) * factor;
        const g = rgb1[1] + (rgb2[1] - rgb1[1]) * factor;
        const b = rgb1[2] + (rgb2[2] - rgb1[2]) * factor;
        
        return rgbToHex(r, g, b);
    }

    // --------------------------------------------------------------------------
    // --- COLOR MAPPING: Using Generic Intensity Value for Future PM2.5 Hook ---
    // --------------------------------------------------------------------------
    
    /**
     * Maps generic intensity value to color, interpolating between fixed hazard levels.
     * * NOTE: This function currently uses a synthetic 'intensityValue' derived from the 
     * simulation's decay rate. In the future, 'intensityValue' should be replaced by 
     * the actual PM2.5 data fetched from an API or model result.
     */
    function colorForIntensity(intensityValue) {
        // Renamed PM constants to generic Intensity constants
        const INTENSITY_MAX = 150; 
        const INTENSITY_RED_THRESHOLD = 120; 
        const INTENSITY_ORANGE_THRESHOLD = 80;
        const INTENSITY_YELLOW_THRESHOLD = 40;
        
        const COLOR_RED = "#FF0000";
        const COLOR_ORANGE = "#FF8C00";
        const COLOR_YELLOW = "#FFFF00";
        const COLOR_GREY = "#808080";

        if (intensityValue >= INTENSITY_RED_THRESHOLD) {
            return COLOR_RED; 
        } else if (intensityValue >= INTENSITY_ORANGE_THRESHOLD) {
            const factor = (INTENSITY_RED_THRESHOLD - intensityValue) / (INTENSITY_RED_THRESHOLD - INTENSITY_ORANGE_THRESHOLD); 
            return interpolateColor(COLOR_RED, COLOR_ORANGE, factor);
        } else if (intensityValue >= INTENSITY_YELLOW_THRESHOLD) {
            const factor = (INTENSITY_ORANGE_THRESHOLD - intensityValue) / (INTENSITY_ORANGE_THRESHOLD - INTENSITY_YELLOW_THRESHOLD);
            return interpolateColor(COLOR_ORANGE, COLOR_YELLOW, factor);
        } else {
            const clampedIntensity = Math.max(5, intensityValue); 
            const factor = (INTENSITY_YELLOW_THRESHOLD - clampedIntensity) / (INTENSITY_YELLOW_THRESHOLD - 5);
            return interpolateColor(COLOR_YELLOW, COLOR_GREY, factor);
        }
    }

    /**
     * Defines the radius in meters based on the forecast hour (h) to show spread over time.
     */
    function radiusForHour(h){ 
        const factor = (h - 1) / (MAX_HOURS - 1); 
        const dynamicRadius = MIN_RADIUS_M + factor * (MAX_RADIUS_M - MIN_RADIUS_M);
        return dynamicRadius; 
    }

    function clearHaze(){
        hazeLayers.forEach(l => map.removeLayer(l));
        hazeLayers = [];
    }
    
    function clearMarkers() {
        cityMarkers.forEach(l => map.removeLayer(l));
        cityMarkers = [];
    }

    function clearCustomMarker() {
        if (customStartMarker) {
            map.removeLayer(customStartMarker);
            customStartMarker = null;
            customStartLat = null;
            customStartLon = null;
        }
    }
    
    // ----------------------------------------------------
    // --- Single Wind Forecast Fetch (Open-Meteo Logic) ---
    // ----------------------------------------------------
    
    /**
     * Fetches the 5-day (120 hour) wind forecast for the selected location.
     */
    async function fetch24HourWindForecast(lat, lon, sourceName) {
        toast(`Fetching 5-day (120 hour) wind forecast for ${sourceName} from Open-Meteo...`);
        
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=windspeed_10m,winddirection_10m&forecast_days=5`;
        
        const MAX_RETRIES = 3;
        const DELAY_MS = 1000;
        
        for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}`);
                }
                
                const data = await response.json(); 
                
                if (!data.hourly || !data.hourly.windspeed_10m || !data.hourly.winddirection_10m) {
                    throw new Error("API returned invalid structure (missing hourly data).");
                }
                
                const speeds = data.hourly.windspeed_10m.slice(0, MAX_HOURS);
                const directions = data.hourly.winddirection_10m.slice(0, MAX_HOURS);
                
                if (speeds.length < MAX_HOURS || directions.length < MAX_HOURS) {
                    throw new Error(`API returned only ${speeds.length} hours of data, need ${MAX_HOURS}.`);
                }

                hourlyWindForecast = speeds.map((speed, index) => ({
                    hour: index + 1, 
                    speed: speed,
                    direction: directions[index] 
                }));
                
                // Update display with the new full forecast
                let html = `<strong>5-Day (120 Hour) Wind Forecast (${sourceName} - Open-Meteo):</strong><ul class="list-unstyled text-xs p-1 m-0">`;
                hourlyWindForecast.forEach(w => {
                    const speed = typeof w.speed === 'number' ? w.speed.toFixed(1) : w.speed;
                    html += `<li class="d-flex justify-content-between"><span>Hour ${w.hour.toString().padStart(3, '0')}:</span> <span>${speed} km/h @ ${w.direction}¬∞</span></li>`;
                });
                html += '</ul>';
                document.getElementById("windForecastDisplay").innerHTML = html;

                toast(`5-day wind forecast successfully loaded for ${sourceName}.`);
                return true;

            } catch (error) {
                if (attempt < MAX_RETRIES - 1) {
                    await new Promise(resolve => setTimeout(resolve, DELAY_MS * Math.pow(2, attempt)));
                } else {
                    console.error("Wind Forecast API Error:", error);
                    document.getElementById("windForecastDisplay").innerHTML = `
                        <p class="text-danger text-center mt-2">Error: Could not fetch 5-day wind forecast from Open-Meteo API after ${MAX_RETRIES} attempts. Check console.</p>
                    `;
                    toast(`API Error: ${error.message}`);
                    hourlyWindForecast = []; 
                    return false;
                }
            }
        }
    }


    // ----------------------------------------------------------
    // --- CORE LOGIC: Local Plume Spread (Dynamic Visuals) ---
    // ----------------------------------------------------------

    /**
     * Simulates the movement of 1 core plume and 8 randomized satellite plumes over 120 hours.
     */
    function simulateLocalHazeSpread(centerLat, centerLon, initialPmValue) {
        console.log(`Starting local simulation from Lat: ${centerLat}, Lon: ${centerLon} with initial PM: ${initialPmValue}`);
        
        const results = [];
        
        // Initial plume center is the initial fire coordinate (hour 0).
        let currentPlumeCenterLat = centerLat;
        let currentPlumeCenterLon = centerLon;
        // Use the initial value passed from runSimulation (fetched or default)
        let currentPM25 = initialPmValue; 

        for (let h = 1; h <= MAX_HOURS; h++) {
            if (h > hourlyWindForecast.length) {
                console.error(`Missing wind data for hour ${h}. Stopping simulation.`);
                break;
            }

            const wind = hourlyWindForecast[h - 1]; // Get wind data for the current hour
            const windSpeed = wind.speed;
            const windDirDeg = wind.direction;
            const windRad = windDirDeg * (Math.PI / 180);
            
            // 1. Calculate new plume center location for THIS hour (Advection)
            const hourlyWindShift = windSpeed * DEGREE_PER_KMH;
            
            const nextPlumeCenterLat = currentPlumeCenterLat + hourlyWindShift * Math.cos(windRad);
            const nextPlumeCenterLon = currentPlumeCenterLon + hourlyWindShift * Math.sin(windRad);
            
            currentPlumeCenterLat = nextPlumeCenterLat;
            currentPlumeCenterLon = nextPlumeCenterLon;


            // 2. Update Haze Intensity (Deterministic Decay)
            currentPM25 *= HAZE_DECAY;
            let basePM25 = currentPM25; 
            if (basePM25 < 5) basePM25 = 5; // Clamp min PM2.5
            
            // 3. Add Core Plume Point (Deterministic path and PM)
            results.push({
                is_core: true,
                latitude: currentPlumeCenterLat,
                longitude: currentPlumeCenterLon,
                predicted_pm25: basePM25 * 1.05, // Core is slightly denser
                forecast_hour: h
            });

            // 4. Add Satellite Plumes (Randomized scatter scaled by plume radius)
            
            // Calculate the current visual radius (in meters)
            const currentVisualRadiusM = radiusForHour(h); 
            
            // Satellite max displacement (in degrees) = (Visual Radius in meters * Ratio) * DEG_PER_METER
            const maxScatterDistanceDeg = (currentVisualRadiusM * SATELLITE_RADIUS_RATIO) * DEG_PER_METER; 

            for (let i = 0; i < NUM_SATELLITES; i++) {
                
                // Randomize angle (0 to 2*PI)
                const randomAngle = Math.random() * 2 * Math.PI;
                // Randomize distance (0 to max scatter distance in degrees)
                const randomDistDeg = Math.random() * maxScatterDistanceDeg; 
                
                // Calculate offsets based on random vector
                const offsetLat = randomDistDeg * Math.cos(randomAngle);
                const offsetLon = randomDistDeg * Math.sin(randomAngle);
                
                // Determine final position (relative to the new core plume center)
                const satelliteLat = currentPlumeCenterLat + offsetLat; 
                const satelliteLon = currentPlumeCenterLon + offsetLon; 
                
                // Use a noisy version of PM2.5 for satellite visualization
                const satellitePM25 = basePM25 * (0.8 + Math.random() * 0.15); // 80% to 95% of core PM

                results.push({
                    is_core: false,
                    latitude: satelliteLat,
                    longitude: satelliteLon,
                    predicted_pm25: satellitePM25,
                    forecast_hour: h
                });
            }
        }
        
        console.log(`Local simulation generated ${results.length} predictions.`);
        return results;
    }
    
    // --- City Loading Logic ---

    /**
     * Loads cities from the API, populates the dropdown, and draws the initial city dots.
     */
    async function loadCities() {
        try {
            toast("Loading cities...");
            const r = await fetch(API_ROOT + "/api/cities");
            
            if (!r.ok) {
                toast(`Error loading cities: Status ${r.status}`);
                throw new Error(`HTTP error! status: ${r.status}`);
            }
            
            const d = await r.json();

            const dropdown = document.getElementById("cityDropdown");
            
            // Store the currently loaded cities, keeping the "Select a City" and "Custom" options
            const selectOptions = dropdown.querySelector('option[value=""]').outerHTML;
            const customOption = dropdown.querySelector('option[value="custom"]').outerHTML;
            dropdown.innerHTML = selectOptions;

            if (!d.cities || d.cities.length === 0) {
                toast("Error: Could not load cities from API.");
                dropdown.innerHTML += customOption; // Still allow custom input
                return;
            }

            clearMarkers(); 
            clearHaze(); 

            d.cities.forEach(c => {
                cityCoordinates[c.city] = c;
                
                const opt = document.createElement("option");
                opt.value = c.city;
                opt.innerText = c.city;
                dropdown.appendChild(opt);

                // Create city marker on the map
                const marker = L.circleMarker([c.latitude, c.longitude], {
                    radius:8, 
                    color:"#06b6d4", 
                    fillColor:"#22d3ee",
                    fillOpacity:0.8,
                    weight:1,
                    // IMPORTANT: Explicitly disable interaction to prevent hover effects and clicking
                    interactive: false 
                }).addTo(map);

                // Marker dot no longer needs popup if non-interactive, but keeping bindPopup for completeness
                marker.bindPopup(`<b>${c.city}</b><br>Preset Haze Source Point.`);
                cityMarkers.push(marker);
            });
            
            dropdown.innerHTML += customOption; // Add custom option back in
            
            toast(`Cities loaded. Select a city, or choose 'Custom Location' to click the map.`);
            
        } catch (error) {
            console.error("Error loading cities:", error);
            toast(`Error loading cities. Please check the network connection. (${error.message})`);
        }
    }

    /**
     * Runs the simulation: fetches the forecast and initiates the haze spread.
     */
    async function runSimulation(){
        let lat, lon, sourceName;
        const selectedValue = document.getElementById("cityDropdown").value;
        
        if (selectedValue === "custom") {
            // Case 1: Custom map location
            if (customStartLat === null || customStartLon === null) {
                toast("Error: Please click on the map to set the custom starting point first.");
                return;
            }
            lat = customStartLat;
            lon = customStartLon;
            sourceName = `Custom (${lat.toFixed(2)}, ${lon.toFixed(2)})`;
            
        } else if (selectedValue && cityCoordinates[selectedValue]) {
            // Case 2: Preset City selected
            const c = cityCoordinates[selectedValue];
            lat = c.latitude;
            lon = c.longitude;
            sourceName = selectedValue;
        } else {
            // Case 3: Nothing selected
            toast("Error: Please select a starting city or a custom location.");
            return;
        }

        // Clear previous animation state
        if (autoplayInterval) {
            clearInterval(autoplayInterval);
            autoplayInterval = null;
        }
        clearHaze();
        hourlyWindForecast = []; 

        // Close the custom marker popup before simulation starts
        if (customStartMarker && customStartMarker.getPopup() && customStartMarker.isPopupOpen()) {
            customStartMarker.closePopup();
        }
        
        // --- PM FETCH LOGIC ---
        let initialPm25 = INITIAL_PM25;
        
        // Fetch real current PM from backend
        try {
            const pmResp = await fetch(`${API_ROOT}/predict?city=${sourceName}`);
            
            // Added check for response success to prevent parsing errors on 404/500
            if (pmResp.ok) {
                const pmData = await pmResp.json();
                if (pmData && typeof pmData.predicted_pm25 === 'number') {
                    // This is the value that will be used by the simulation's decay model
                    initialPm25 = parseFloat(pmData.predicted_pm25); 
                    console.log(`Initial PM data fetched and used: ${initialPm25.toFixed(2)} ¬µg/m¬≥.`);
                } else {
                    console.warn(`PM data fetch successful but 'predicted_pm25' not found or invalid. Using default ${INITIAL_PM25}.`);
                }
            } else {
                console.warn(`Could not fetch initial PM data from backend. Status: ${pmResp.status}. Using default ${INITIAL_PM25}.`);
            }
        } catch (error) {
            // This catches network errors (like server being down)
            console.error("Network error during PM fetch:", error);
            console.warn(`PM fetch failed due to network error. Using default ${INITIAL_PM25}.`);
        }
        // --- END PM FETCH LOGIC ---


        // 1. Fetch the 5-day wind forecast using Geo coordinates
        const fetchSuccessful = await fetch24HourWindForecast(lat, lon, sourceName);
        
        if (!fetchSuccessful) {
            return;
        }

        toast(`Running 5-day haze simulation from ${sourceName} with 120-hour forecast... üí®`);

        // --- EXECUTE LOCAL MODEL ---
        // Pass the fetched/default PM value to the simulation function
        predictions = simulateLocalHazeSpread(lat, lon, initialPm25); 
        // ---------------------------
        
        // Fly in on the selected location with zoom 12
        map.flyTo([lat, lon], 12, {animate:true, duration:1.5}); 
        
        if (predictions.length > 0) {
            toast("Simulation complete. Playing haze spread... üå¨Ô∏è");
            playAnimation();
        } else {
            toast("Local simulation failed to generate data.");
        }
    }

    /**
     * Starts the 120-hour animation loop (like a video player).
     */
    function playAnimation(){
        clearHaze();
        let hour=1;
        document.getElementById("sliderPanel").style.display = "flex"; // Show controls

        if (autoplayInterval) {
            clearInterval(autoplayInterval);
        }
        
        showHour(hour); 
        hour++;

        autoplayInterval = setInterval(()=>{
            showHour(hour);
            hour++;
            if(hour > MAX_HOURS){
                clearInterval(autoplayInterval);
                autoplayInterval = null;
                toast("Playback finished. Use slider to inspect manually.");
            }
        }, 100); 
    }

    /**
     * Draws the prediction data for a specific hour based on the toggle view mode.
     */
    function showHour(h){
        clearHaze();
        document.getElementById("hourSlider").value = h;
        
        // DYNAMIC HOUR INDICATOR: Convert total hours to Day/Hour format
        const day = Math.floor((h - 1) / 24) + 1;
        const hourInDay = (h % 24 === 0) ? 24 : h % 24;
        document.getElementById("hourLabel").innerText = `Day ${day}, Hour ${hourInDay} (Total: ${h})`;
        
        const isCumulative = document.getElementById("viewModeToggle").checked;
        
        const hourData = predictions.filter(p => 
            isCumulative ? p.forecast_hour <= h : p.forecast_hour === h
        );

        hourData.forEach(p => {
            const intensityValue = p.predicted_pm25; 
            const col = colorForIntensity(intensityValue); // Color now based on intensity
            const dynamicRadius = radiusForHour(p.forecast_hour); 
            
            const wind = hourlyWindForecast[p.forecast_hour - 1];
            const speed = wind ? wind.speed.toFixed(1) : 'N/A';
            const direction = wind ? wind.direction : 'N/A';

            // Draw a circle for each predicted point
            const ring = L.circle([p.latitude, p.longitude],{
                radius:dynamicRadius, 
                color:col,
                fillColor:col,
                fillOpacity:0.125, 
                weight:0 
            }).addTo(map);

            // Add popup with details for inspection
            ring.bindPopup(`
                <b>Hour ${p.forecast_hour} Prediction</b><br>
                PM2.5: ${p.predicted_pm25.toFixed(2)} ¬µg/m¬≥<br>
                Wind: ${speed} km/h @ ${direction}¬∞
            `);

            hazeLayers.push(ring);
        });
    }

    // --- Event Handlers ---

    // Handler for the "Run Haze Simulation" button
    document.getElementById("simulateLocal").onclick = runSimulation;

    // Handler for City Dropdown selection
    document.getElementById("cityDropdown").addEventListener("change", async e => {
        const selectedValue = e.target.value;
        const c = cityCoordinates[selectedValue];
        
        // Clear previous state
        if (autoplayInterval) { clearInterval(autoplayInterval); autoplayInterval = null; }
        clearHaze();
        hourlyWindForecast = []; 

        if (selectedValue === "custom") {
            // Enable map clicks and show instructions
            isMapClickEnabled = true;
            document.getElementById("customInstructions").style.display = 'block';
            toast("Mode: Custom Location. Click on the map to set a point.");
        } else {
            // Disable map clicks and clear custom marker
            isMapClickEnabled = false;
            document.getElementById("customInstructions").style.display = 'none';
            clearCustomMarker();
            
            if (c) {
                // Zoom to 12 when selecting from dropdown 
                map.flyTo([c.latitude, c.longitude], 12, { duration: 1.0 });
                document.getElementById("windForecastDisplay").innerHTML = `
                    <p class="text-center text-light-override">Selected ${selectedValue}. Click 'Run Simulation' to fetch forecast.</p>
                `;
                toast(`City changed to ${selectedValue}. Ready to run simulation.`);
            } else {
                document.getElementById("windForecastDisplay").innerHTML = `<p class="text-center text-light-override">Select a city or custom location, then press 'Run Haze Simulation'.</p>`;
                toast("Ready.");
            }
        }
    });

    // Handler for Map Click (Custom Source Point) - NOW GUARDED BY isMapClickEnabled
    map.on('click', (e) => {
        if (!isMapClickEnabled) {
            toast("Select 'Set Custom Location on Map' from the dropdown to enable map clicking.");
            return;
        }

        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        
        // 1. Clear previous custom marker
        clearCustomMarker();
        
        // 2. Store coordinates
        customStartLat = lat;
        customStartLon = lon;
        
        // 3. Add new custom marker
        customStartMarker = L.marker([lat, lon], {
            icon: L.divIcon({
                className: 'custom-start-icon',
                html: `<div style="background-color: ${'var(--accent-color)'}; width: 15px; height: 15px; border-radius: 50%; border: 3px solid white;"></div>`,
                iconSize: [15, 15],
                iconAnchor: [7.5, 7.5]
            })
        }).addTo(map);

        // Bind the popup so the user can click the marker to see coordinates, but don't open it immediately
        customStartMarker.bindPopup(`<b>Custom Source Set</b><br>Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`).openPopup();
        
        // Zoom to the new location
        map.flyTo([lat, lon], 12, { duration: 0.5 }); 

        // Update UI status
        document.getElementById("windForecastDisplay").innerHTML = `
            <p class="text-center text-light-override">Custom location set. Click 'Run Haze Simulation' to fetch forecast.</p>
        `;
        toast("Custom location set. Click 'Run Haze Simulation'.");
    });
    
    // Toggle handler for view mode
    document.getElementById("viewModeToggle").addEventListener("change", e => {
        const isChecked = e.target.checked;
        document.getElementById("toggleLabel").innerText = isChecked ? "Cumulative View" : "Hourly View";
        
        // Re-render the current hour based on the new view mode
        const currentHour = parseInt(document.getElementById("hourSlider").value);
        if (predictions.length > 0) {
            showHour(currentHour);
        }
        
        // Stop autoplay if running
        if (autoplayInterval) {
            clearInterval(autoplayInterval);
            autoplayInterval = null;
            toast(`Autoplay paused. Switched to ${isChecked ? 'Cumulative' : 'Hourly'} View.`);
        }
    });


    // Handle slider interaction (stops autoplay)
    document.getElementById("hourSlider").addEventListener("input", e=>{
        if (autoplayInterval) {
            clearInterval(autoplayInterval);
            autoplayInterval = null;
            toast("Autoplay paused. Inspecting manually.");
        }
        const hour = parseInt(e.target.value);
        if (predictions.length > 0) {
            showHour(hour);
        } else {
            document.getElementById("hourLabel").innerText = "Hour: "+hour;
        }
    });

    // Replay button handler
    document.getElementById("replayBtn").onclick = ()=>{
        if (predictions.length > 0) {
            playAnimation();
            toast("Replaying simulation... üí®");
        } else {
            toast("Please run a simulation first.");
        }
    };

    // --- Initialization ---
    window.onload = loadCities;
</script>
</body>
</html>